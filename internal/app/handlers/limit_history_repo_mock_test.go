// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package handlers

//go:generate minimock -i screen-time-limiter/internal/app/handlers.limitHistoryRepo -o limit_history_repo_mock_test.go -n LimitHistoryRepoMock -p handlers

import (
	"context"
	"screen-time-limiter/internal/domain/model"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LimitHistoryRepoMock implements limitHistoryRepo
type LimitHistoryRepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcPush          func(ctx context.Context, history model.LimitHistory) (err error)
	funcPushOrigin    string
	inspectFuncPush   func(ctx context.Context, history model.LimitHistory)
	afterPushCounter  uint64
	beforePushCounter uint64
	PushMock          mLimitHistoryRepoMockPush

	funcSum          func(ctx context.Context, limitID int32, date time.Time) (i1 int, err error)
	funcSumOrigin    string
	inspectFuncSum   func(ctx context.Context, limitID int32, date time.Time)
	afterSumCounter  uint64
	beforeSumCounter uint64
	SumMock          mLimitHistoryRepoMockSum
}

// NewLimitHistoryRepoMock returns a mock for limitHistoryRepo
func NewLimitHistoryRepoMock(t minimock.Tester) *LimitHistoryRepoMock {
	m := &LimitHistoryRepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.PushMock = mLimitHistoryRepoMockPush{mock: m}
	m.PushMock.callArgs = []*LimitHistoryRepoMockPushParams{}

	m.SumMock = mLimitHistoryRepoMockSum{mock: m}
	m.SumMock.callArgs = []*LimitHistoryRepoMockSumParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLimitHistoryRepoMockPush struct {
	optional           bool
	mock               *LimitHistoryRepoMock
	defaultExpectation *LimitHistoryRepoMockPushExpectation
	expectations       []*LimitHistoryRepoMockPushExpectation

	callArgs []*LimitHistoryRepoMockPushParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LimitHistoryRepoMockPushExpectation specifies expectation struct of the limitHistoryRepo.Push
type LimitHistoryRepoMockPushExpectation struct {
	mock               *LimitHistoryRepoMock
	params             *LimitHistoryRepoMockPushParams
	paramPtrs          *LimitHistoryRepoMockPushParamPtrs
	expectationOrigins LimitHistoryRepoMockPushExpectationOrigins
	results            *LimitHistoryRepoMockPushResults
	returnOrigin       string
	Counter            uint64
}

// LimitHistoryRepoMockPushParams contains parameters of the limitHistoryRepo.Push
type LimitHistoryRepoMockPushParams struct {
	ctx     context.Context
	history model.LimitHistory
}

// LimitHistoryRepoMockPushParamPtrs contains pointers to parameters of the limitHistoryRepo.Push
type LimitHistoryRepoMockPushParamPtrs struct {
	ctx     *context.Context
	history *model.LimitHistory
}

// LimitHistoryRepoMockPushResults contains results of the limitHistoryRepo.Push
type LimitHistoryRepoMockPushResults struct {
	err error
}

// LimitHistoryRepoMockPushOrigins contains origins of expectations of the limitHistoryRepo.Push
type LimitHistoryRepoMockPushExpectationOrigins struct {
	origin        string
	originCtx     string
	originHistory string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPush *mLimitHistoryRepoMockPush) Optional() *mLimitHistoryRepoMockPush {
	mmPush.optional = true
	return mmPush
}

// Expect sets up expected params for limitHistoryRepo.Push
func (mmPush *mLimitHistoryRepoMockPush) Expect(ctx context.Context, history model.LimitHistory) *mLimitHistoryRepoMockPush {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("LimitHistoryRepoMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &LimitHistoryRepoMockPushExpectation{}
	}

	if mmPush.defaultExpectation.paramPtrs != nil {
		mmPush.mock.t.Fatalf("LimitHistoryRepoMock.Push mock is already set by ExpectParams functions")
	}

	mmPush.defaultExpectation.params = &LimitHistoryRepoMockPushParams{ctx, history}
	mmPush.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPush.expectations {
		if minimock.Equal(e.params, mmPush.defaultExpectation.params) {
			mmPush.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPush.defaultExpectation.params)
		}
	}

	return mmPush
}

// ExpectCtxParam1 sets up expected param ctx for limitHistoryRepo.Push
func (mmPush *mLimitHistoryRepoMockPush) ExpectCtxParam1(ctx context.Context) *mLimitHistoryRepoMockPush {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("LimitHistoryRepoMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &LimitHistoryRepoMockPushExpectation{}
	}

	if mmPush.defaultExpectation.params != nil {
		mmPush.mock.t.Fatalf("LimitHistoryRepoMock.Push mock is already set by Expect")
	}

	if mmPush.defaultExpectation.paramPtrs == nil {
		mmPush.defaultExpectation.paramPtrs = &LimitHistoryRepoMockPushParamPtrs{}
	}
	mmPush.defaultExpectation.paramPtrs.ctx = &ctx
	mmPush.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPush
}

// ExpectHistoryParam2 sets up expected param history for limitHistoryRepo.Push
func (mmPush *mLimitHistoryRepoMockPush) ExpectHistoryParam2(history model.LimitHistory) *mLimitHistoryRepoMockPush {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("LimitHistoryRepoMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &LimitHistoryRepoMockPushExpectation{}
	}

	if mmPush.defaultExpectation.params != nil {
		mmPush.mock.t.Fatalf("LimitHistoryRepoMock.Push mock is already set by Expect")
	}

	if mmPush.defaultExpectation.paramPtrs == nil {
		mmPush.defaultExpectation.paramPtrs = &LimitHistoryRepoMockPushParamPtrs{}
	}
	mmPush.defaultExpectation.paramPtrs.history = &history
	mmPush.defaultExpectation.expectationOrigins.originHistory = minimock.CallerInfo(1)

	return mmPush
}

// Inspect accepts an inspector function that has same arguments as the limitHistoryRepo.Push
func (mmPush *mLimitHistoryRepoMockPush) Inspect(f func(ctx context.Context, history model.LimitHistory)) *mLimitHistoryRepoMockPush {
	if mmPush.mock.inspectFuncPush != nil {
		mmPush.mock.t.Fatalf("Inspect function is already set for LimitHistoryRepoMock.Push")
	}

	mmPush.mock.inspectFuncPush = f

	return mmPush
}

// Return sets up results that will be returned by limitHistoryRepo.Push
func (mmPush *mLimitHistoryRepoMockPush) Return(err error) *LimitHistoryRepoMock {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("LimitHistoryRepoMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &LimitHistoryRepoMockPushExpectation{mock: mmPush.mock}
	}
	mmPush.defaultExpectation.results = &LimitHistoryRepoMockPushResults{err}
	mmPush.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPush.mock
}

// Set uses given function f to mock the limitHistoryRepo.Push method
func (mmPush *mLimitHistoryRepoMockPush) Set(f func(ctx context.Context, history model.LimitHistory) (err error)) *LimitHistoryRepoMock {
	if mmPush.defaultExpectation != nil {
		mmPush.mock.t.Fatalf("Default expectation is already set for the limitHistoryRepo.Push method")
	}

	if len(mmPush.expectations) > 0 {
		mmPush.mock.t.Fatalf("Some expectations are already set for the limitHistoryRepo.Push method")
	}

	mmPush.mock.funcPush = f
	mmPush.mock.funcPushOrigin = minimock.CallerInfo(1)
	return mmPush.mock
}

// When sets expectation for the limitHistoryRepo.Push which will trigger the result defined by the following
// Then helper
func (mmPush *mLimitHistoryRepoMockPush) When(ctx context.Context, history model.LimitHistory) *LimitHistoryRepoMockPushExpectation {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("LimitHistoryRepoMock.Push mock is already set by Set")
	}

	expectation := &LimitHistoryRepoMockPushExpectation{
		mock:               mmPush.mock,
		params:             &LimitHistoryRepoMockPushParams{ctx, history},
		expectationOrigins: LimitHistoryRepoMockPushExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPush.expectations = append(mmPush.expectations, expectation)
	return expectation
}

// Then sets up limitHistoryRepo.Push return parameters for the expectation previously defined by the When method
func (e *LimitHistoryRepoMockPushExpectation) Then(err error) *LimitHistoryRepoMock {
	e.results = &LimitHistoryRepoMockPushResults{err}
	return e.mock
}

// Times sets number of times limitHistoryRepo.Push should be invoked
func (mmPush *mLimitHistoryRepoMockPush) Times(n uint64) *mLimitHistoryRepoMockPush {
	if n == 0 {
		mmPush.mock.t.Fatalf("Times of LimitHistoryRepoMock.Push mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPush.expectedInvocations, n)
	mmPush.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPush
}

func (mmPush *mLimitHistoryRepoMockPush) invocationsDone() bool {
	if len(mmPush.expectations) == 0 && mmPush.defaultExpectation == nil && mmPush.mock.funcPush == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPush.mock.afterPushCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPush.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Push implements limitHistoryRepo
func (mmPush *LimitHistoryRepoMock) Push(ctx context.Context, history model.LimitHistory) (err error) {
	mm_atomic.AddUint64(&mmPush.beforePushCounter, 1)
	defer mm_atomic.AddUint64(&mmPush.afterPushCounter, 1)

	mmPush.t.Helper()

	if mmPush.inspectFuncPush != nil {
		mmPush.inspectFuncPush(ctx, history)
	}

	mm_params := LimitHistoryRepoMockPushParams{ctx, history}

	// Record call args
	mmPush.PushMock.mutex.Lock()
	mmPush.PushMock.callArgs = append(mmPush.PushMock.callArgs, &mm_params)
	mmPush.PushMock.mutex.Unlock()

	for _, e := range mmPush.PushMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPush.PushMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPush.PushMock.defaultExpectation.Counter, 1)
		mm_want := mmPush.PushMock.defaultExpectation.params
		mm_want_ptrs := mmPush.PushMock.defaultExpectation.paramPtrs

		mm_got := LimitHistoryRepoMockPushParams{ctx, history}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPush.t.Errorf("LimitHistoryRepoMock.Push got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPush.PushMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.history != nil && !minimock.Equal(*mm_want_ptrs.history, mm_got.history) {
				mmPush.t.Errorf("LimitHistoryRepoMock.Push got unexpected parameter history, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPush.PushMock.defaultExpectation.expectationOrigins.originHistory, *mm_want_ptrs.history, mm_got.history, minimock.Diff(*mm_want_ptrs.history, mm_got.history))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPush.t.Errorf("LimitHistoryRepoMock.Push got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPush.PushMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPush.PushMock.defaultExpectation.results
		if mm_results == nil {
			mmPush.t.Fatal("No results are set for the LimitHistoryRepoMock.Push")
		}
		return (*mm_results).err
	}
	if mmPush.funcPush != nil {
		return mmPush.funcPush(ctx, history)
	}
	mmPush.t.Fatalf("Unexpected call to LimitHistoryRepoMock.Push. %v %v", ctx, history)
	return
}

// PushAfterCounter returns a count of finished LimitHistoryRepoMock.Push invocations
func (mmPush *LimitHistoryRepoMock) PushAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPush.afterPushCounter)
}

// PushBeforeCounter returns a count of LimitHistoryRepoMock.Push invocations
func (mmPush *LimitHistoryRepoMock) PushBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPush.beforePushCounter)
}

// Calls returns a list of arguments used in each call to LimitHistoryRepoMock.Push.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPush *mLimitHistoryRepoMockPush) Calls() []*LimitHistoryRepoMockPushParams {
	mmPush.mutex.RLock()

	argCopy := make([]*LimitHistoryRepoMockPushParams, len(mmPush.callArgs))
	copy(argCopy, mmPush.callArgs)

	mmPush.mutex.RUnlock()

	return argCopy
}

// MinimockPushDone returns true if the count of the Push invocations corresponds
// the number of defined expectations
func (m *LimitHistoryRepoMock) MinimockPushDone() bool {
	if m.PushMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PushMock.invocationsDone()
}

// MinimockPushInspect logs each unmet expectation
func (m *LimitHistoryRepoMock) MinimockPushInspect() {
	for _, e := range m.PushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LimitHistoryRepoMock.Push at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPushCounter := mm_atomic.LoadUint64(&m.afterPushCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PushMock.defaultExpectation != nil && afterPushCounter < 1 {
		if m.PushMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LimitHistoryRepoMock.Push at\n%s", m.PushMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LimitHistoryRepoMock.Push at\n%s with params: %#v", m.PushMock.defaultExpectation.expectationOrigins.origin, *m.PushMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPush != nil && afterPushCounter < 1 {
		m.t.Errorf("Expected call to LimitHistoryRepoMock.Push at\n%s", m.funcPushOrigin)
	}

	if !m.PushMock.invocationsDone() && afterPushCounter > 0 {
		m.t.Errorf("Expected %d calls to LimitHistoryRepoMock.Push at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PushMock.expectedInvocations), m.PushMock.expectedInvocationsOrigin, afterPushCounter)
	}
}

type mLimitHistoryRepoMockSum struct {
	optional           bool
	mock               *LimitHistoryRepoMock
	defaultExpectation *LimitHistoryRepoMockSumExpectation
	expectations       []*LimitHistoryRepoMockSumExpectation

	callArgs []*LimitHistoryRepoMockSumParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LimitHistoryRepoMockSumExpectation specifies expectation struct of the limitHistoryRepo.Sum
type LimitHistoryRepoMockSumExpectation struct {
	mock               *LimitHistoryRepoMock
	params             *LimitHistoryRepoMockSumParams
	paramPtrs          *LimitHistoryRepoMockSumParamPtrs
	expectationOrigins LimitHistoryRepoMockSumExpectationOrigins
	results            *LimitHistoryRepoMockSumResults
	returnOrigin       string
	Counter            uint64
}

// LimitHistoryRepoMockSumParams contains parameters of the limitHistoryRepo.Sum
type LimitHistoryRepoMockSumParams struct {
	ctx     context.Context
	limitID int32
	date    time.Time
}

// LimitHistoryRepoMockSumParamPtrs contains pointers to parameters of the limitHistoryRepo.Sum
type LimitHistoryRepoMockSumParamPtrs struct {
	ctx     *context.Context
	limitID *int32
	date    *time.Time
}

// LimitHistoryRepoMockSumResults contains results of the limitHistoryRepo.Sum
type LimitHistoryRepoMockSumResults struct {
	i1  int
	err error
}

// LimitHistoryRepoMockSumOrigins contains origins of expectations of the limitHistoryRepo.Sum
type LimitHistoryRepoMockSumExpectationOrigins struct {
	origin        string
	originCtx     string
	originLimitID string
	originDate    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSum *mLimitHistoryRepoMockSum) Optional() *mLimitHistoryRepoMockSum {
	mmSum.optional = true
	return mmSum
}

// Expect sets up expected params for limitHistoryRepo.Sum
func (mmSum *mLimitHistoryRepoMockSum) Expect(ctx context.Context, limitID int32, date time.Time) *mLimitHistoryRepoMockSum {
	if mmSum.mock.funcSum != nil {
		mmSum.mock.t.Fatalf("LimitHistoryRepoMock.Sum mock is already set by Set")
	}

	if mmSum.defaultExpectation == nil {
		mmSum.defaultExpectation = &LimitHistoryRepoMockSumExpectation{}
	}

	if mmSum.defaultExpectation.paramPtrs != nil {
		mmSum.mock.t.Fatalf("LimitHistoryRepoMock.Sum mock is already set by ExpectParams functions")
	}

	mmSum.defaultExpectation.params = &LimitHistoryRepoMockSumParams{ctx, limitID, date}
	mmSum.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSum.expectations {
		if minimock.Equal(e.params, mmSum.defaultExpectation.params) {
			mmSum.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSum.defaultExpectation.params)
		}
	}

	return mmSum
}

// ExpectCtxParam1 sets up expected param ctx for limitHistoryRepo.Sum
func (mmSum *mLimitHistoryRepoMockSum) ExpectCtxParam1(ctx context.Context) *mLimitHistoryRepoMockSum {
	if mmSum.mock.funcSum != nil {
		mmSum.mock.t.Fatalf("LimitHistoryRepoMock.Sum mock is already set by Set")
	}

	if mmSum.defaultExpectation == nil {
		mmSum.defaultExpectation = &LimitHistoryRepoMockSumExpectation{}
	}

	if mmSum.defaultExpectation.params != nil {
		mmSum.mock.t.Fatalf("LimitHistoryRepoMock.Sum mock is already set by Expect")
	}

	if mmSum.defaultExpectation.paramPtrs == nil {
		mmSum.defaultExpectation.paramPtrs = &LimitHistoryRepoMockSumParamPtrs{}
	}
	mmSum.defaultExpectation.paramPtrs.ctx = &ctx
	mmSum.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSum
}

// ExpectLimitIDParam2 sets up expected param limitID for limitHistoryRepo.Sum
func (mmSum *mLimitHistoryRepoMockSum) ExpectLimitIDParam2(limitID int32) *mLimitHistoryRepoMockSum {
	if mmSum.mock.funcSum != nil {
		mmSum.mock.t.Fatalf("LimitHistoryRepoMock.Sum mock is already set by Set")
	}

	if mmSum.defaultExpectation == nil {
		mmSum.defaultExpectation = &LimitHistoryRepoMockSumExpectation{}
	}

	if mmSum.defaultExpectation.params != nil {
		mmSum.mock.t.Fatalf("LimitHistoryRepoMock.Sum mock is already set by Expect")
	}

	if mmSum.defaultExpectation.paramPtrs == nil {
		mmSum.defaultExpectation.paramPtrs = &LimitHistoryRepoMockSumParamPtrs{}
	}
	mmSum.defaultExpectation.paramPtrs.limitID = &limitID
	mmSum.defaultExpectation.expectationOrigins.originLimitID = minimock.CallerInfo(1)

	return mmSum
}

// ExpectDateParam3 sets up expected param date for limitHistoryRepo.Sum
func (mmSum *mLimitHistoryRepoMockSum) ExpectDateParam3(date time.Time) *mLimitHistoryRepoMockSum {
	if mmSum.mock.funcSum != nil {
		mmSum.mock.t.Fatalf("LimitHistoryRepoMock.Sum mock is already set by Set")
	}

	if mmSum.defaultExpectation == nil {
		mmSum.defaultExpectation = &LimitHistoryRepoMockSumExpectation{}
	}

	if mmSum.defaultExpectation.params != nil {
		mmSum.mock.t.Fatalf("LimitHistoryRepoMock.Sum mock is already set by Expect")
	}

	if mmSum.defaultExpectation.paramPtrs == nil {
		mmSum.defaultExpectation.paramPtrs = &LimitHistoryRepoMockSumParamPtrs{}
	}
	mmSum.defaultExpectation.paramPtrs.date = &date
	mmSum.defaultExpectation.expectationOrigins.originDate = minimock.CallerInfo(1)

	return mmSum
}

// Inspect accepts an inspector function that has same arguments as the limitHistoryRepo.Sum
func (mmSum *mLimitHistoryRepoMockSum) Inspect(f func(ctx context.Context, limitID int32, date time.Time)) *mLimitHistoryRepoMockSum {
	if mmSum.mock.inspectFuncSum != nil {
		mmSum.mock.t.Fatalf("Inspect function is already set for LimitHistoryRepoMock.Sum")
	}

	mmSum.mock.inspectFuncSum = f

	return mmSum
}

// Return sets up results that will be returned by limitHistoryRepo.Sum
func (mmSum *mLimitHistoryRepoMockSum) Return(i1 int, err error) *LimitHistoryRepoMock {
	if mmSum.mock.funcSum != nil {
		mmSum.mock.t.Fatalf("LimitHistoryRepoMock.Sum mock is already set by Set")
	}

	if mmSum.defaultExpectation == nil {
		mmSum.defaultExpectation = &LimitHistoryRepoMockSumExpectation{mock: mmSum.mock}
	}
	mmSum.defaultExpectation.results = &LimitHistoryRepoMockSumResults{i1, err}
	mmSum.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSum.mock
}

// Set uses given function f to mock the limitHistoryRepo.Sum method
func (mmSum *mLimitHistoryRepoMockSum) Set(f func(ctx context.Context, limitID int32, date time.Time) (i1 int, err error)) *LimitHistoryRepoMock {
	if mmSum.defaultExpectation != nil {
		mmSum.mock.t.Fatalf("Default expectation is already set for the limitHistoryRepo.Sum method")
	}

	if len(mmSum.expectations) > 0 {
		mmSum.mock.t.Fatalf("Some expectations are already set for the limitHistoryRepo.Sum method")
	}

	mmSum.mock.funcSum = f
	mmSum.mock.funcSumOrigin = minimock.CallerInfo(1)
	return mmSum.mock
}

// When sets expectation for the limitHistoryRepo.Sum which will trigger the result defined by the following
// Then helper
func (mmSum *mLimitHistoryRepoMockSum) When(ctx context.Context, limitID int32, date time.Time) *LimitHistoryRepoMockSumExpectation {
	if mmSum.mock.funcSum != nil {
		mmSum.mock.t.Fatalf("LimitHistoryRepoMock.Sum mock is already set by Set")
	}

	expectation := &LimitHistoryRepoMockSumExpectation{
		mock:               mmSum.mock,
		params:             &LimitHistoryRepoMockSumParams{ctx, limitID, date},
		expectationOrigins: LimitHistoryRepoMockSumExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSum.expectations = append(mmSum.expectations, expectation)
	return expectation
}

// Then sets up limitHistoryRepo.Sum return parameters for the expectation previously defined by the When method
func (e *LimitHistoryRepoMockSumExpectation) Then(i1 int, err error) *LimitHistoryRepoMock {
	e.results = &LimitHistoryRepoMockSumResults{i1, err}
	return e.mock
}

// Times sets number of times limitHistoryRepo.Sum should be invoked
func (mmSum *mLimitHistoryRepoMockSum) Times(n uint64) *mLimitHistoryRepoMockSum {
	if n == 0 {
		mmSum.mock.t.Fatalf("Times of LimitHistoryRepoMock.Sum mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSum.expectedInvocations, n)
	mmSum.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSum
}

func (mmSum *mLimitHistoryRepoMockSum) invocationsDone() bool {
	if len(mmSum.expectations) == 0 && mmSum.defaultExpectation == nil && mmSum.mock.funcSum == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSum.mock.afterSumCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSum.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Sum implements limitHistoryRepo
func (mmSum *LimitHistoryRepoMock) Sum(ctx context.Context, limitID int32, date time.Time) (i1 int, err error) {
	mm_atomic.AddUint64(&mmSum.beforeSumCounter, 1)
	defer mm_atomic.AddUint64(&mmSum.afterSumCounter, 1)

	mmSum.t.Helper()

	if mmSum.inspectFuncSum != nil {
		mmSum.inspectFuncSum(ctx, limitID, date)
	}

	mm_params := LimitHistoryRepoMockSumParams{ctx, limitID, date}

	// Record call args
	mmSum.SumMock.mutex.Lock()
	mmSum.SumMock.callArgs = append(mmSum.SumMock.callArgs, &mm_params)
	mmSum.SumMock.mutex.Unlock()

	for _, e := range mmSum.SumMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmSum.SumMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSum.SumMock.defaultExpectation.Counter, 1)
		mm_want := mmSum.SumMock.defaultExpectation.params
		mm_want_ptrs := mmSum.SumMock.defaultExpectation.paramPtrs

		mm_got := LimitHistoryRepoMockSumParams{ctx, limitID, date}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSum.t.Errorf("LimitHistoryRepoMock.Sum got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSum.SumMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limitID != nil && !minimock.Equal(*mm_want_ptrs.limitID, mm_got.limitID) {
				mmSum.t.Errorf("LimitHistoryRepoMock.Sum got unexpected parameter limitID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSum.SumMock.defaultExpectation.expectationOrigins.originLimitID, *mm_want_ptrs.limitID, mm_got.limitID, minimock.Diff(*mm_want_ptrs.limitID, mm_got.limitID))
			}

			if mm_want_ptrs.date != nil && !minimock.Equal(*mm_want_ptrs.date, mm_got.date) {
				mmSum.t.Errorf("LimitHistoryRepoMock.Sum got unexpected parameter date, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSum.SumMock.defaultExpectation.expectationOrigins.originDate, *mm_want_ptrs.date, mm_got.date, minimock.Diff(*mm_want_ptrs.date, mm_got.date))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSum.t.Errorf("LimitHistoryRepoMock.Sum got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSum.SumMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSum.SumMock.defaultExpectation.results
		if mm_results == nil {
			mmSum.t.Fatal("No results are set for the LimitHistoryRepoMock.Sum")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmSum.funcSum != nil {
		return mmSum.funcSum(ctx, limitID, date)
	}
	mmSum.t.Fatalf("Unexpected call to LimitHistoryRepoMock.Sum. %v %v %v", ctx, limitID, date)
	return
}

// SumAfterCounter returns a count of finished LimitHistoryRepoMock.Sum invocations
func (mmSum *LimitHistoryRepoMock) SumAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSum.afterSumCounter)
}

// SumBeforeCounter returns a count of LimitHistoryRepoMock.Sum invocations
func (mmSum *LimitHistoryRepoMock) SumBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSum.beforeSumCounter)
}

// Calls returns a list of arguments used in each call to LimitHistoryRepoMock.Sum.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSum *mLimitHistoryRepoMockSum) Calls() []*LimitHistoryRepoMockSumParams {
	mmSum.mutex.RLock()

	argCopy := make([]*LimitHistoryRepoMockSumParams, len(mmSum.callArgs))
	copy(argCopy, mmSum.callArgs)

	mmSum.mutex.RUnlock()

	return argCopy
}

// MinimockSumDone returns true if the count of the Sum invocations corresponds
// the number of defined expectations
func (m *LimitHistoryRepoMock) MinimockSumDone() bool {
	if m.SumMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SumMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SumMock.invocationsDone()
}

// MinimockSumInspect logs each unmet expectation
func (m *LimitHistoryRepoMock) MinimockSumInspect() {
	for _, e := range m.SumMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LimitHistoryRepoMock.Sum at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSumCounter := mm_atomic.LoadUint64(&m.afterSumCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SumMock.defaultExpectation != nil && afterSumCounter < 1 {
		if m.SumMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LimitHistoryRepoMock.Sum at\n%s", m.SumMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LimitHistoryRepoMock.Sum at\n%s with params: %#v", m.SumMock.defaultExpectation.expectationOrigins.origin, *m.SumMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSum != nil && afterSumCounter < 1 {
		m.t.Errorf("Expected call to LimitHistoryRepoMock.Sum at\n%s", m.funcSumOrigin)
	}

	if !m.SumMock.invocationsDone() && afterSumCounter > 0 {
		m.t.Errorf("Expected %d calls to LimitHistoryRepoMock.Sum at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SumMock.expectedInvocations), m.SumMock.expectedInvocationsOrigin, afterSumCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LimitHistoryRepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockPushInspect()

			m.MinimockSumInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LimitHistoryRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LimitHistoryRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockPushDone() &&
		m.MinimockSumDone()
}
